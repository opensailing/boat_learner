# A Star

```elixir
Mix.install([
  {:boat_learner, path: "#{__DIR__}/.."},
  {:kino_vega_lite, "~> 0.1"},
  {:tucan, "~> 0.3"}
])
```

## A Star Boat Planning Demo

```elixir
Nx.default_backend(EXLA.Backend)
Nx.Defn.default_options(compiler: EXLA)
```

```elixir
target_x = 0
target_y = 250
min_x = -300
max_x = 300
min_y = -10
max_y = 300

{time, result} =
  :timer.tc(fn ->
    BoatLearner.AStar.solve({0, 0}, {target_x, target_y},
      start_heading: 0,
      boat_length: 7,
      max_x: max_x,
      min_x: min_x,
      min_y: min_y,
      max_y: max_y,
      dt: 5,
      grid_resolution: 4,
      tacking_penalty: 10
    )
  end)

IO.puts("Executed in #{time / 1_000_000} seconds.")
{:ok, path} = result
path
```

```elixir
angles_i = Enum.to_list(40..180//1)
angles = angles_i ++ Enum.map(angles_i, &(-&1))
angles_t = Nx.tensor(angles) |> Nx.multiply(:math.pi() / 180)

polar = BoatLearner.AStar.init_polar_chart()
speeds = BoatLearner.AStar.speed_from_heading(polar, angles_t)

Tucan.new(x: angles_i ++ Enum.map(angles_i, &(-&1)), y: Nx.cos(angles_t) |> Nx.multiply(speeds))
|> Tucan.lineplot("x", "y", points: true, tooltip: :data)
|> Tucan.set_height(600)
|> Tucan.set_width(600)
```

```elixir
angles_t = Nx.tensor([-45, -40, 40, -45]) |> Nx.multiply(:math.pi() / 180)
speeds = BoatLearner.AStar.speed_from_heading(polar, angles_t)

BoatLearner.AStar.vmg(0, 0, 0, 250, angles_t, speeds, Nx.tensor([0, 0]))
```

```elixir
xs = Enum.map(path, & &1.x)
ys = Enum.map(path, & &1.y)

headings =
  Enum.map(path, fn %{heading: h} ->
    ang = h * 180 / :math.pi()

    if ang > 180 do
      ang - 360
    else
      ang
    end
  end)

speeds = Enum.map(path, & &1.speed)

Tucan.new(x: xs, y: ys, index: Enum.to_list(0..length(xs)), headings: headings, speeds: speeds)
|> Tucan.set_height(600)
|> Tucan.set_width(600)
|> Tucan.Scale.set_x_domain(min_x, max_x)
|> Tucan.Scale.set_y_domain(min_y, max_y)
|> Tucan.Grid.set_width(:x, 2)
|> Tucan.Grid.set_width(:y, 2)
|> Tucan.Layers.append([
  Tucan.new()
  |> Tucan.lineplot("x", "y",
    tooltip: :data,
    points: true,
    x: [type: :quantitative],
    y: [type: :quantitative]
  )
  |> VegaLite.encode_field(:order, "index"),
  Tucan.new(target_x: [target_x], target_y: [target_y])
  |> Tucan.scatter("target_x", "target_y",
    filled: true,
    fill_opacity: 1,
    point_color: "black",
    point_size: 200,
    point_shape: "cross"
  )
])
```
